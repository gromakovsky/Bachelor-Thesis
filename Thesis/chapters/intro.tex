% -*-coding: utf-8-*-
\startprefacepage

Задача поиска кратчайшего пути при наличии полигональных препятствий
хорошо известна и исследована. Классический способ решения этой задачи
описан в~\cite{de2000computational}. Одним из её практических
применений является поиск кратчайшего маршрута на морских картах, то
есть кратчайшего пути между двумя точками, проходящего по воде. Однако
при нахождении единственного кратчайшего маршрута возникают различные
проблемы.

Во-первых, кратчайший путь не всегда является действительно
оптимальным, с точки зрения пользователя. Например, на пути могут быть
каналы, проплыть через которые возможно только за большую плату, что
сделает такой маршрут менее привлекательным, чем какой-то другой,
более длинный маршрут. В каких-то местах может быть нежелательно
плавать по политическим соображениям, также у капитана корабля могут
личные предпочтения. Формализовать всё множество критериев,
описывающих оптимальность маршрута, едва ли представляется возможным.

Во-вторых, иногда может возникнуть ситуация, при которой
воспользоваться кратчайшим маршрутом не представляется возможным.
Например, где-то могут проходить военные учения, из-за чего проплыть в
таких местах будет запрещено. Также данные карты, по которой строился
маршрут, могли устареть, и какая-то река или канал могли полностью
высохнуть. В таком случае пользователю хочется иметь альтернативный
маршрут.

В-третьих, иногда нужно направить большое количество кораблей из одной
точки в другую. Если сотни кораблей пойдут одним маршрутом, то они
могут потратить очень много времени в очереди, чтобы проплыть по
какому-нибудь каналу. Если же корабли пустить разными маршрутами, то
суммарные временные затраты могут быть существенно уменьшены, несмотря
на то что часть кораблей поплывёт не по кратчайшему пути.

Таким образом, возникает задача поиска семейств маршрутов между двумя
точками. При этом маршруты должны быть в некотором смысле оптимальны.
Например, логично требовать, чтобы маршруты были не сильно длиннее
кратчайшего и попарно непохожи. Сама по себе данная задача не приводит
к конечному результату, а лишь осуществляет поддержу для принятия
решения. Окончательное решение принимается пользователем в голове,
поэтому основное требование к задачам поддержки принятия решения
состоит в том, что они должны решаться практически моментально, в
режиме реального времени, чтобы не сбивать пользователя с мыслей.

Для задачи поиска нескольких маршрутов (multipath planning) также
известны некоторые решения. Например, существуют различные алгоритмы
решения задачи $K$-shortest paths, состоящей в поиске первых $K$ путей
в графе по возрастанию длины~\cite{eppstein1998finding,
yen1971finding}. Однако нетрудно понять, что такие пути имеют много
общих рёбер и являются очень похожими. Также известны и другие
алгоритмы multipath planning~\cite{lim2005shortest,
dial1971probabilistic, mafast}. Например,
алгоритм~\cite{lim2005shortest} находит пути, которые имеют как можно
меньше общих рёбер, однако при его применении к имеющейся задачи
получаются слишком похожие маршруты. Это связано с тем, что если есть
два маршрута, один из которых проходит на километр южнее другого, то
они, как правило, хоть и почти не имеют общих рёбер, по сути являются
очень похожими.

\todo{Последний параграф не готов}

В первой главе приведён подробный обзор предметной области и
существующих алгоритмов, сформулирована формальная постановка задачи.
Во второй главе описано теоретическое решение поставленной задачи,
рассмотрены вопросы предобработки исходных данных и поиска семейств
маршрутов. В третьей главе описываются некоторые детали реализации и
вообще всякая разная фигня написана, но вообще-то ещё не написана, так
что потом напишу это предложение.

\FloatBarrier

